/**
 * Base client for Websets API
 */

/**
 * Type for API query parameters
 */
type QueryParams$1 = Record<string, string | number | boolean | string[] | undefined>;
/**
 * Type for API request body
 */
interface RequestBody$1 {
    [key: string]: unknown;
}
/**
 * Common pagination parameters
 */
interface PaginationParams {
    /**
     * Cursor for pagination
     */
    cursor?: string;
    /**
     * Maximum number of items per page
     */
    limit?: number;
}
/**
 * Base client class for all Websets-related API clients
 */
declare class WebsetsBaseClient {
    protected client: Exa;
    /**
     * Initialize a new Websets base client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Make a request to the Websets API
     * @param endpoint The endpoint path
     * @param method The HTTP method
     * @param data Optional request body data
     * @param params Optional query parameters
     * @returns The response JSON
     * @throws ExaError with API error details if the request fails
     */
    protected request<T = unknown>(endpoint: string, method?: string, data?: RequestBody$1, params?: QueryParams$1): Promise<T>;
    /**
     * Helper to build pagination parameters
     * @param pagination The pagination parameters
     * @returns QueryParams object with pagination parameters
     */
    protected buildPaginationParams(pagination?: PaginationParams): QueryParams$1;
}

interface components {
    schemas: {
        CreateCriterionParameters: {
            /** @description The description of the criterion */
            description: string;
        };
        CreateEnrichmentParameters: {
            /** @description Provide a description of the enrichment task you want to perform to each Webset Item. */
            description: string;
            /**
             * @description Format of the enrichment response.
             *
             *     We automatically select the best format based on the description. If you want to explicitly specify the format, you can do so here.
             * @enum {string}
             */
            format?: CreateEnrichmentParametersFormat;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description When the format is options, the different options for the enrichment agent to choose from. */
            options?: {
                /** @description The label of the option */
                label: string;
            }[];
        };
        CreateWebhookParameters: {
            /** @description The events to trigger the webhook */
            events: components["schemas"]["EventType"][];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url: string;
        };
        CreateWebsetParameters: {
            /** @description Add Enrichments for the Webset. */
            enrichments?: components["schemas"]["CreateEnrichmentParameters"][];
            /** @description The external identifier for the webset.
             *
             *     You can use this to reference the Webset by your own internal identifiers. */
            externalId?: string;
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description Create initial search for the Webset. */
            search: {
                /**
                 * @description Number of Items the Webset will attempt to find.
                 *
                 *     The actual number of Items found may be less than this number depending on the search complexity.
                 * @default 10
                 */
                count: number;
                /** @description Criteria every item is evaluated against.
                 *
                 *     It's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. Only use this when you need more fine control. */
                criteria?: components["schemas"]["CreateCriterionParameters"][];
                /** @description Entity the Webset will return results for.
                 *
                 *     It is not required to provide it, we automatically detect the entity from all the information provided in the query. Only use this when you need more fine control. */
                entity?: components["schemas"]["WebsetEntity"];
                /** @description Your search query.
                 *
                 *     Use this to describe what you are looking for.
                 *
                 *     Any URL provided will be crawled and used as context for the search. */
                query: string;
            };
        };
        CreateWebsetSearchParameters: {
            /**
             * WebsetSearchBehaviour
             * @description The behaviour of the Search when it is added to a Webset.
             *
             *     - `override`: the search will reuse the existing Items found in the Webset and evaluate them against the new criteria. Any Items that don't match the new criteria will be discarded.
             * @default override
             * @enum {string}
             */
            behaviour: CreateWebsetSearchParametersBehaviour;
            /** @description Number of Items the Search will attempt to find.
             *
             *     The actual number of Items found may be less than this number depending on the query complexity. */
            count: number;
            /** @description Criteria every item is evaluated against.
             *
             *     It's not required to provide your own criteria, we automatically detect the criteria from all the information provided in the query. */
            criteria?: components["schemas"]["CreateCriterionParameters"][];
            /** @description Entity the Webset will return results for.
             *
             *     It is not required to provide it, we automatically detect the entity from all the information provided in the query. */
            entity?: components["schemas"]["WebsetEntity"];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /** @description Query describing what you are looking for.
             *
             *     Any URL provided will be crawled and used as context for the search. */
            query: string;
        };
        EnrichmentResult: {
            /** @description The id of the Enrichment that generated the result */
            enrichmentId: string;
            format: components["schemas"]["WebsetEnrichmentFormat"];
            /**
             * @default enrichment_result
             * @constant
             */
            object: "enrichment_result";
            /** @description The reasoning for the result when an Agent is used. */
            reasoning: string | null;
            /** @description The references used to generate the result. */
            references: {
                /** @description The relevant snippet of the reference content */
                snippet: string | null;
                /** @description The title of the reference */
                title: string | null;
                /** @description The URL of the reference */
                url: string;
            }[];
            /** @description The result of the enrichment. */
            result: string[] | null;
        };
        /** Event */
        Event: {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.created
             * @constant
             */
            type: "webset.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.deleted
             * @constant
             */
            type: "webset.deleted";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.idle
             * @constant
             */
            type: "webset.idle";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["Webset"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.paused
             * @constant
             */
            type: "webset.paused";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetItem"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.item.created
             * @constant
             */
            type: "webset.item.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetItem"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.item.enriched
             * @constant
             */
            type: "webset.item.enriched";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.created
             * @constant
             */
            type: "webset.search.created";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.updated
             * @constant
             */
            type: "webset.search.updated";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.canceled
             * @constant
             */
            type: "webset.search.canceled";
        } | {
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt: string;
            data: components["schemas"]["WebsetSearch"];
            /** @description The unique identifier for the event */
            id: string;
            /**
             * @default event
             * @constant
             */
            object: "event";
            /**
             * @default webset.search.completed
             * @constant
             */
            type: "webset.search.completed";
        };
        /** @enum {string} */
        EventType: EventType;
        GetWebsetResponse: components["schemas"]["Webset"] & {
            /** @description When expand query parameter contains `items`, this will contain the items in the webset */
            items?: components["schemas"]["WebsetItem"][];
        };
        ListEventsResponse: {
            /** @description The list of events */
            data: components["schemas"]["Event"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebhookAttemptsResponse: {
            /** @description The list of webhook attempts */
            data: components["schemas"]["WebhookAttempt"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebhooksResponse: {
            /** @description The list of webhooks */
            data: components["schemas"]["Webhook"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        ListWebsetItemResponse: {
            /** @description The list of webset items */
            data: components["schemas"]["WebsetItem"][];
            /** @description Whether there are more Items to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of Items */
            nextCursor: string | null;
        };
        ListWebsetsResponse: {
            /** @description The list of websets */
            data: components["schemas"]["Webset"][];
            /** @description Whether there are more results to paginate through */
            hasMore: boolean;
            /** @description The cursor to paginate through the next set of results */
            nextCursor: string | null;
        };
        UpdateWebhookParameters: {
            /** @description The events to trigger the webhook */
            events?: components["schemas"]["EventType"][];
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            };
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url?: string;
        };
        UpdateWebsetRequest: {
            /** @description Set of key-value pairs you want to associate with this object. */
            metadata?: {
                [key: string]: string;
            } | null;
        };
        Webhook: {
            /**
             * Format: date-time
             * @description The date and time the webhook was created
             */
            createdAt: string;
            /** @description The events to trigger the webhook */
            events: components["schemas"]["EventType"][];
            /** @description The unique identifier for the webhook */
            id: string;
            /**
             * @description The metadata of the webhook
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webhook
             * @constant
             */
            object: "webhook";
            /** @description The secret to verify the webhook signature. Only returned on Webhook creation. */
            secret: string | null;
            /**
             * WebhookStatus
             * @description The status of the webhook
             * @enum {string}
             */
            status: WebhookStatus;
            /**
             * Format: date-time
             * @description The date and time the webhook was last updated
             */
            updatedAt: string;
            /**
             * Format: uri
             * @description The URL to send the webhook to
             */
            url: string;
        };
        WebhookAttempt: {
            /** @description The attempt number of the webhook */
            attempt: number;
            /**
             * Format: date-time
             * @description The date and time the webhook attempt was made
             */
            attemptedAt: string;
            /** @description The unique identifier for the event */
            eventId: string;
            /**
             * @description The type of event
             * @enum {string}
             */
            eventType: EventType;
            /** @description The unique identifier for the webhook attempt */
            id: string;
            /**
             * @default webhook_attempt
             * @constant
             */
            object: "webhook_attempt";
            /** @description The body of the response */
            responseBody: string | null;
            /** @description The headers of the response */
            responseHeaders: {
                [key: string]: string;
            };
            /** @description The status code of the response */
            responseStatusCode: number;
            /** @description Whether the attempt was successful */
            successful: boolean;
            /** @description The URL that was used during the attempt */
            url: string;
            /** @description The unique identifier for the webhook */
            webhookId: string;
        };
        Webset: {
            /**
             * Format: date-time
             * @description The date and time the webset was created
             */
            createdAt: string;
            /** @description The Enrichments to apply to the Webset Items. */
            enrichments: components["schemas"]["WebsetEnrichment"][];
            /** @description The external identifier for the webset */
            externalId: string | null;
            /** @description The unique identifier for the webset */
            id: string;
            /**
             * @description Set of key-value pairs you want to associate with this object.
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webset
             * @constant
             */
            object: "webset";
            /** @description The searches that have been performed on the webset. */
            searches: components["schemas"]["WebsetSearch"][];
            /**
             * WebsetStatus
             * @description The status of the webset
             * @enum {string}
             */
            status: WebsetStatus;
            /**
             * Format: date-time
             * @description The date and time the webset was updated
             */
            updatedAt: string;
        };
        WebsetArticleEntity: {
            /**
             * @default article
             * @constant
             */
            type: "article";
        };
        WebsetCompanyEntity: {
            /**
             * @default company
             * @constant
             */
            type: "company";
        };
        WebsetCustomEntity: {
            /** @description When you decide to use a custom entity, this is the description of the entity.
             *
             *     The entity represents what type of results the Webset will return. For example, if you want results to be Job Postings, you might use "Job Postings" as the entity description. */
            description: string;
            /**
             * @default custom
             * @constant
             */
            type: "custom";
        };
        WebsetEnrichment: {
            /**
             * Format: date-time
             * @description The date and time the enrichment was created
             */
            createdAt: string;
            /** @description The description of the enrichment task provided during the creation of the enrichment. */
            description: string;
            /** @description The format of the enrichment response. */
            format: components["schemas"]["WebsetEnrichmentFormat"];
            /** @description The unique identifier for the enrichment */
            id: string;
            /** @description The instructions for the enrichment Agent.
             *
             *     This will be automatically generated based on the description and format. */
            instructions: string | null;
            /**
             * @description The metadata of the enrichment
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webset_enrichment
             * @constant
             */
            object: "webset_enrichment";
            /**
             * WebsetEnrichmentOptions
             * @description When the format is options, the different options for the enrichment agent to choose from.
             */
            options: {
                /** @description The label of the option */
                label: string;
            }[] | null;
            /**
             * WebsetEnrichmentStatus
             * @description The status of the enrichment
             * @enum {string}
             */
            status: WebsetEnrichmentStatus;
            /** @description The title of the enrichment.
             *
             *     This will be automatically generated based on the description and format. */
            title: string | null;
            /**
             * Format: date-time
             * @description The date and time the enrichment was updated
             */
            updatedAt: string;
            /** @description The unique identifier for the Webset this enrichment belongs to. */
            websetId: string;
        };
        /** @enum {string} */
        WebsetEnrichmentFormat: WebsetEnrichmentFormat;
        WebsetEntity: components["schemas"]["WebsetCompanyEntity"] | components["schemas"]["WebsetPersonEntity"] | components["schemas"]["WebsetArticleEntity"] | components["schemas"]["WebsetResearchPaperEntity"] | components["schemas"]["WebsetCustomEntity"];
        WebsetItem: {
            /**
             * Format: date-time
             * @description The date and time the item was created
             */
            createdAt: string;
            /** @description The enrichments results of the Webset item */
            enrichments: components["schemas"]["EnrichmentResult"][] | null;
            /** @description The criteria evaluations of the item */
            evaluations: components["schemas"]["WebsetItemEvaluation"][];
            /** @description The unique identifier for the Webset Item */
            id: string;
            /**
             * @default webset_item
             * @constant
             */
            object: "webset_item";
            /** @description The properties of the Item */
            properties: components["schemas"]["WebsetItemPersonProperties"] | components["schemas"]["WebsetItemCompanyProperties"] | components["schemas"]["WebsetItemArticleProperties"] | components["schemas"]["WebsetItemResearchPaperProperties"] | components["schemas"]["WebsetItemCustomProperties"];
            /**
             * @description The source of the Item
             * @enum {string}
             */
            source: WebsetItemSource;
            /** @description The unique identifier for the source */
            sourceId: string;
            /**
             * Format: date-time
             * @description The date and time the item was last updated
             */
            updatedAt: string;
            /** @description The unique identifier for the Webset this Item belongs to. */
            websetId: string;
        };
        WebsetItemArticleProperties: {
            /** WebsetItemArticlePropertiesFields */
            article: {
                /** @description The author(s) of the article */
                author: string | null;
                /** @description The date and time the article was published */
                publishedAt: string | null;
            };
            /** @description The text content for the article */
            content: string | null;
            /** @description Short description of the relevance of the article */
            description: string;
            /**
             * @default article
             * @constant
             */
            type: "article";
            /**
             * Format: uri
             * @description The URL of the article
             */
            url: string;
        };
        WebsetItemCompanyProperties: {
            /** WebsetItemCompanyPropertiesFields */
            company: {
                /** @description A short description of the company */
                about: string | null;
                /** @description The number of employees of the company */
                employees: number | null;
                /** @description The industry of the company */
                industry: string | null;
                /** @description The main location of the company */
                location: string | null;
                /**
                 * Format: uri
                 * @description The logo URL of the company
                 */
                logoUrl: string | null;
                /** @description The name of the company */
                name: string;
            };
            /** @description The text content of the company website */
            content: string | null;
            /** @description Short description of the relevance of the company */
            description: string;
            /**
             * @default company
             * @constant
             */
            type: "company";
            /**
             * Format: uri
             * @description The URL of the company website
             */
            url: string;
        };
        WebsetItemCustomProperties: {
            /** @description The text content of the Item */
            content: string | null;
            /** WebsetItemCustomPropertiesFields */
            custom: {
                /** @description The author(s) of the website */
                author: string | null;
                /** @description The date and time the website was published */
                publishedAt: string | null;
            };
            /** @description Short description of the Item */
            description: string;
            /**
             * @default custom
             * @constant
             */
            type: "custom";
            /**
             * Format: uri
             * @description The URL of the Item
             */
            url: string;
        };
        WebsetItemEvaluation: {
            /** @description The description of the criterion */
            criterion: string;
            /** @description The reasoning for the result of the evaluation */
            reasoning: string;
            /**
             * @description The references used to generate the result.
             * @default []
             */
            references: {
                /** @description The relevant snippet of the reference content */
                snippet: string | null;
                /** @description The title of the reference */
                title: string | null;
                /** @description The URL of the reference */
                url: string;
            }[];
            /**
             * @description The satisfaction of the criterion
             * @enum {string}
             */
            satisfied: WebsetItemEvaluationSatisfied;
        };
        WebsetItemPersonProperties: {
            /** @description Short description of the relevance of the person */
            description: string;
            /** WebsetItemPersonPropertiesFields */
            person: {
                /** @description The location of the person */
                location: string | null;
                /** @description The name of the person */
                name: string;
                /**
                 * Format: uri
                 * @description The image URL of the person
                 */
                pictureUrl: string | null;
                /** @description The current work position of the person */
                position: string | null;
            };
            /**
             * @default person
             * @constant
             */
            type: "person";
            /**
             * Format: uri
             * @description The URL of the person profile
             */
            url: string;
        };
        WebsetItemResearchPaperProperties: {
            /** @description The text content of the research paper */
            content: string | null;
            /** @description Short description of the relevance of the research paper */
            description: string;
            /** WebsetItemResearchPaperPropertiesFields */
            researchPaper: {
                /** @description The author(s) of the research paper */
                author: string | null;
                /** @description The date and time the research paper was published */
                publishedAt: string | null;
            };
            /**
             * @default research_paper
             * @constant
             */
            type: "research_paper";
            /**
             * Format: uri
             * @description The URL of the research paper
             */
            url: string;
        };
        WebsetPersonEntity: {
            /**
             * @default person
             * @constant
             */
            type: "person";
        };
        WebsetResearchPaperEntity: {
            /**
             * @default research_paper
             * @constant
             */
            type: "research_paper";
        };
        WebsetSearch: {
            /**
             * Format: date-time
             * @description The date and time the search was canceled
             */
            canceledAt: string | null;
            /**
             * @description The reason the search was canceled
             * @enum {string|null}
             */
            canceledReason: WebsetSearchCanceledReason;
            /** @description The number of results the search will attempt to find. The actual number of results may be less than this number depending on the search complexity. */
            count: number;
            /**
             * Format: date-time
             * @description The date and time the search was created
             */
            createdAt: string;
            /** @description The criteria the search will use to evaluate the results. If not provided, we will automatically generate them for you. */
            criteria: {
                /** @description The description of the criterion */
                description: string;
                /** @description Value between 0 and 100 representing the percentage of results that meet the criterion. */
                successRate: number;
            }[];
            /** @description The entity the search will return results for.
             *
             *     When no entity is provided during creation, we will automatically select the best entity based on the query. */
            entity: components["schemas"]["WebsetEntity"];
            /** @description The unique identifier for the search */
            id: string;
            /**
             * @description Set of key-value pairs you want to associate with this object.
             * @default {}
             */
            metadata: {
                [key: string]: string;
            };
            /**
             * @default webset_search
             * @constant
             */
            object: "webset_search";
            /** @description The progress of the search */
            progress: {
                /** @description The completion percentage of the search */
                completion: number;
                /** @description The number of results found so far */
                found: number;
            };
            /** @description The query used to create the search. */
            query: string;
            /**
             * WebsetSearchStatus
             * @description The status of the search
             * @enum {string}
             */
            status: WebsetSearchStatus;
            /**
             * Format: date-time
             * @description The date and time the search was updated
             */
            updatedAt: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
type CreateEnrichmentParameters = components["schemas"]["CreateEnrichmentParameters"];
type CreateWebhookParameters = components["schemas"]["CreateWebhookParameters"];
type CreateWebsetParameters = components["schemas"]["CreateWebsetParameters"];
type CreateWebsetSearchParameters = components["schemas"]["CreateWebsetSearchParameters"];
type EnrichmentResult = components["schemas"]["EnrichmentResult"];
type Event = components["schemas"]["Event"];
type GetWebsetResponse = components["schemas"]["GetWebsetResponse"];
type ListEventsResponse = components["schemas"]["ListEventsResponse"];
type ListWebhookAttemptsResponse = components["schemas"]["ListWebhookAttemptsResponse"];
type ListWebhooksResponse = components["schemas"]["ListWebhooksResponse"];
type ListWebsetItemResponse = components["schemas"]["ListWebsetItemResponse"];
type ListWebsetsResponse = components["schemas"]["ListWebsetsResponse"];
type UpdateWebhookParameters = components["schemas"]["UpdateWebhookParameters"];
type UpdateWebsetRequest = components["schemas"]["UpdateWebsetRequest"];
type Webhook = components["schemas"]["Webhook"];
type WebhookAttempt = components["schemas"]["WebhookAttempt"];
type Webset = components["schemas"]["Webset"];
type WebsetEnrichment = components["schemas"]["WebsetEnrichment"];
type WebsetItem = components["schemas"]["WebsetItem"];
type WebsetSearch = components["schemas"]["WebsetSearch"];
declare enum CreateEnrichmentParametersFormat {
    text = "text",
    date = "date",
    number = "number",
    options = "options",
    email = "email",
    phone = "phone"
}
declare enum CreateWebsetSearchParametersBehaviour {
    override = "override"
}
declare enum EventType {
    webset_created = "webset.created",
    webset_deleted = "webset.deleted",
    webset_paused = "webset.paused",
    webset_idle = "webset.idle",
    webset_search_created = "webset.search.created",
    webset_search_canceled = "webset.search.canceled",
    webset_search_completed = "webset.search.completed",
    webset_search_updated = "webset.search.updated",
    webset_export_created = "webset.export.created",
    webset_export_completed = "webset.export.completed",
    webset_item_created = "webset.item.created",
    webset_item_enriched = "webset.item.enriched"
}
declare enum WebhookStatus {
    active = "active",
    inactive = "inactive"
}
declare enum WebsetStatus {
    idle = "idle",
    running = "running",
    paused = "paused"
}
declare enum WebsetEnrichmentStatus {
    pending = "pending",
    canceled = "canceled",
    completed = "completed"
}
declare enum WebsetEnrichmentFormat {
    text = "text",
    date = "date",
    number = "number",
    options = "options",
    email = "email",
    phone = "phone"
}
declare enum WebsetItemSource {
    search = "search"
}
declare enum WebsetItemEvaluationSatisfied {
    yes = "yes",
    no = "no",
    unclear = "unclear"
}
declare enum WebsetSearchCanceledReason {
    webset_deleted = "webset_deleted",
    webset_canceled = "webset_canceled"
}
declare enum WebsetSearchStatus {
    created = "created",
    running = "running",
    completed = "completed",
    canceled = "canceled"
}

/**
 * Client for managing Webset Enrichments
 */

/**
 * Client for managing Webset Enrichments
 */
declare class WebsetEnrichmentsClient extends WebsetsBaseClient {
    /**
     * Create an Enrichment for a Webset
     * @param websetId The ID of the Webset
     * @param params The enrichment parameters
     * @returns The created Webset Enrichment
     */
    create(websetId: string, params: CreateEnrichmentParameters): Promise<WebsetEnrichment>;
    /**
     * Get an Enrichment by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The Webset Enrichment
     */
    get(websetId: string, id: string): Promise<WebsetEnrichment>;
    /**
     * Delete an Enrichment
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The deleted Webset Enrichment
     */
    delete(websetId: string, id: string): Promise<WebsetEnrichment>;
    /**
     * Cancel a running Enrichment
     * @param websetId The ID of the Webset
     * @param id The ID of the Enrichment
     * @returns The canceled Webset Enrichment
     */
    cancel(websetId: string, id: string): Promise<WebsetEnrichment>;
}

/**
 * Options for listing Events
 */
interface ListEventsOptions {
    /**
     * The cursor to paginate through the results
     */
    cursor?: string;
    /**
     * The number of results to return
     */
    limit?: number;
    /**
     * The types of events to filter by
     */
    types?: EventType[];
}
/**
 * Client for managing Events
 */
declare class EventsClient extends WebsetsBaseClient {
    /**
     * Initialize a new Events client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * List all Events
     * @param options Optional filtering and pagination options
     * @returns The list of Events
     */
    list(options?: ListEventsOptions): Promise<ListEventsResponse>;
    /**
     * Get an Event by ID
     * @param id The ID of the Event
     * @returns The Event
     */
    get(id: string): Promise<Event>;
}

/**
 * Client for managing Webset Items
 */

/**
 * Client for managing Webset Items
 */
declare class WebsetItemsClient extends WebsetsBaseClient {
    /**
     * List all Items for a Webset
     * @param websetId The ID of the Webset
     * @param params - Optional pagination parameters
     * @returns A promise that resolves with the list of Items
     */
    list(websetId: string, params?: PaginationParams): Promise<ListWebsetItemResponse>;
    /**
     * Iterate through all Items in a Webset, handling pagination automatically
     * @param websetId The ID of the Webset
     * @param options Pagination options
     * @returns Async generator of Webset Items
     */
    listAll(websetId: string, options?: PaginationParams): AsyncGenerator<WebsetItem>;
    /**
     * Collect all items from a Webset into an array
     * @param websetId The ID of the Webset
     * @param options Pagination options
     * @returns Promise resolving to an array of all Webset Items
     */
    getAll(websetId: string, options?: PaginationParams): Promise<WebsetItem[]>;
    /**
     * Get an Item by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Item
     * @returns The Webset Item
     */
    get(websetId: string, id: string): Promise<WebsetItem>;
    /**
     * Delete an Item
     * @param websetId The ID of the Webset
     * @param id The ID of the Item
     * @returns The deleted Webset Item
     */
    delete(websetId: string, id: string): Promise<WebsetItem>;
}

/**
 * Client for managing Webset Searches
 */

/**
 * Client for managing Webset Searches
 */
declare class WebsetSearchesClient extends WebsetsBaseClient {
    /**
     * Create a new Search for the Webset
     * @param websetId The ID of the Webset
     * @param params The search parameters
     * @returns The created Webset Search
     */
    create(websetId: string, params: CreateWebsetSearchParameters): Promise<WebsetSearch>;
    /**
     * Get a Search by ID
     * @param websetId The ID of the Webset
     * @param id The ID of the Search
     * @returns The Webset Search
     */
    get(websetId: string, id: string): Promise<WebsetSearch>;
    /**
     * Cancel a running Search
     * @param websetId The ID of the Webset
     * @param id The ID of the Search
     * @returns The canceled Webset Search
     */
    cancel(websetId: string, id: string): Promise<WebsetSearch>;
}

/**
 * Client for managing Webset Webhooks
 */

/**
 * Options for listing webhooks (only pagination is supported by API)
 */
interface ListWebhooksOptions extends PaginationParams {
}
/**
 * Options for listing webhook attempts
 */
interface ListWebhookAttemptsOptions extends PaginationParams {
    /**
     * The type of event to filter by
     */
    eventType?: EventType;
}
/**
 * Client for managing Webset Webhooks
 */
declare class WebsetWebhooksClient extends WebsetsBaseClient {
    /**
     * Create a Webhook
     * @param params The webhook parameters
     * @returns The created Webhook
     */
    create(params: CreateWebhookParameters): Promise<Webhook>;
    /**
     * Get a Webhook by ID
     * @param id The ID of the Webhook
     * @returns The Webhook
     */
    get(id: string): Promise<Webhook>;
    /**
     * List all Webhooks
     * @param options Pagination options
     * @returns The list of Webhooks
     */
    list(options?: ListWebhooksOptions): Promise<ListWebhooksResponse>;
    /**
     * Iterate through all Webhooks, handling pagination automatically
     * @param options Pagination options
     * @returns Async generator of Webhooks
     */
    listAll(options?: ListWebhooksOptions): AsyncGenerator<Webhook>;
    /**
     * Collect all Webhooks into an array
     * @param options Pagination options
     * @returns Promise resolving to an array of all Webhooks
     */
    getAll(options?: ListWebhooksOptions): Promise<Webhook[]>;
    /**
     * Update a Webhook
     * @param id The ID of the Webhook
     * @param params The webhook update parameters (events, metadata, url)
     * @returns The updated Webhook
     */
    update(id: string, params: UpdateWebhookParameters): Promise<Webhook>;
    /**
     * Delete a Webhook
     * @param id The ID of the Webhook
     * @returns The deleted Webhook
     */
    delete(id: string): Promise<Webhook>;
    /**
     * List all attempts for a Webhook
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns The list of Webhook attempts
     */
    listAttempts(id: string, options?: ListWebhookAttemptsOptions): Promise<ListWebhookAttemptsResponse>;
    /**
     * Iterate through all attempts for a Webhook, handling pagination automatically
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns Async generator of Webhook attempts
     */
    listAllAttempts(id: string, options?: ListWebhookAttemptsOptions): AsyncGenerator<WebhookAttempt>;
    /**
     * Collect all attempts for a Webhook into an array
     * @param id The ID of the Webhook
     * @param options Pagination and filtering options
     * @returns Promise resolving to an array of all Webhook attempts
     */
    getAllAttempts(id: string, options?: ListWebhookAttemptsOptions): Promise<WebhookAttempt[]>;
}

/**
 * Main client for Websets API
 */

/**
 * Options for listing Websets (API only supports pagination)
 */
interface ListWebsetsOptions extends PaginationParams {
}
/**
 * Client for managing Websets
 */
declare class WebsetsClient extends WebsetsBaseClient {
    /**
     * Client for managing Events
     */
    events: EventsClient;
    /**
     * Client for managing Webset Items
     */
    items: WebsetItemsClient;
    /**
     * Client for managing Webset Searches
     */
    searches: WebsetSearchesClient;
    /**
     * Client for managing Webset Enrichments
     */
    enrichments: WebsetEnrichmentsClient;
    /**
     * Client for managing Webset Webhooks
     */
    webhooks: WebsetWebhooksClient;
    /**
     * Initialize a new Websets client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Create a new Webset
     * @param params The Webset creation parameters
     * @returns The created Webset
     */
    create(params: CreateWebsetParameters): Promise<Webset>;
    /**
     * Get a Webset by ID
     * @param id The ID of the Webset
     * @param expand Optional array of relations to expand
     * @returns The Webset
     */
    get(id: string, expand?: Array<"items">): Promise<GetWebsetResponse>;
    /**
     * List all Websets
     * @param options Pagination options (filtering by status is not supported by API)
     * @returns The list of Websets
     */
    list(options?: ListWebsetsOptions): Promise<ListWebsetsResponse>;
    /**
     * Iterate through all Websets, handling pagination automatically
     * @param options Pagination options
     * @returns Async generator of Websets
     */
    listAll(options?: ListWebsetsOptions): AsyncGenerator<Webset>;
    /**
     * Collect all Websets into an array
     * @param options Pagination options
     * @returns Promise resolving to an array of all Websets
     */
    getAll(options?: ListWebsetsOptions): Promise<Webset[]>;
    /**
     * Update a Webset
     * @param id The ID of the Webset
     * @param params The Webset update parameters
     * @returns The updated Webset
     */
    update(id: string, params: UpdateWebsetRequest): Promise<Webset>;
    /**
     * Delete a Webset
     * @param id The ID of the Webset
     * @returns The deleted Webset
     */
    delete(id: string): Promise<Webset>;
    /**
     * Cancel a running Webset
     * @param id The ID or external ID of the Webset
     * @returns The canceled Webset (as returned by the API)
     */
    cancel(id: string): Promise<Webset>;
    /**
     * Wait until a Webset is idle
     * @param id The ID of the Webset
     * @param options Configuration options for timeout and polling
     * @returns The Webset once it becomes idle
     * @throws Error if the Webset does not become idle within the timeout
     */
    waitUntilIdle(id: string, options?: {
        timeout?: number;
        pollInterval?: number;
        onPoll?: (status: WebsetStatus) => void;
    } | number): Promise<Webset>;
}

/**
 * Enum representing the status of a research task.
 */
declare enum ResearchStatus {
    /** The research request has finished successfully. */
    completed = "completed",
    /** The research request failed. */
    failed = "failed"
}
/**
 * Response object returned from the research API.
 */
type ResearchTaskResponse = {
    /** Unique identifier for the task. */
    id: string;
    /** Current status (may include future enum values served by the API). */
    status: ResearchStatus | string;
    /** Structured output that follows the user-provided schema (null while running). */
    output: Record<string, any> | null;
    /**
     * Citations collected while deriving each top-level field in `output`.
     * The key is the field name, the value is the list of `SearchResult`s that
     * were used to compute that field.
     */
    citations: Record<string, SearchResult<{}>[]>;
};

type QueryParams = Record<string, string | number | boolean | string[] | undefined>;
interface RequestBody {
    [key: string]: unknown;
}
/**
 * Base client class for all Research-related API clients
 */
declare class ResearchBaseClient {
    protected client: Exa;
    /**
     * Initialize a new Research base client
     * @param client The Exa client instance
     */
    constructor(client: Exa);
    /**
     * Make a request to the Research API (prefixes all paths with `/research`).
     * @param endpoint The endpoint path, beginning with a slash (e.g. "/tasks").
     * @param method The HTTP method. Defaults to "POST".
     * @param data Optional request body
     * @param params Optional query parameters
     * @returns The parsed JSON response
     */
    protected request<T = unknown>(endpoint: string, method?: string, data?: RequestBody, params?: QueryParams): Promise<T>;
}

/**
 * Client for interacting with the Research Tasks API.
 */
declare class ResearchClient extends ResearchBaseClient {
    constructor(client: Exa);
    /**
     * Create and run a research task (blocking call).
     *
     * Both parameters are required and have fixed shapes:
     * 1. `input`
     *      `{ instructions: string }`
     *     • `instructions` – High-level guidance that tells the research agent what to do.
     * 2. `output`
     *    defines the exact structure you expect back, and guides the research conducted by the agent.
     *      `{ schema: JSONSchema }`.
     *    The agent's response will be validated against this schema.
     *
     * @param input  Object containing high-level research instructions.
     * @param output Object containing the expected output schema.
     * @returns The ResearchTaskResponse returned by the API.
     */
    createTask(input: {
        instructions: string;
    }, output: {
        schema: JSONSchema;
    }): Promise<ResearchTaskResponse>;
    /**
     * Retrieve a research task by ID.
     *
     * Not yet implemented server-side. Calling this will throw until the API is
     * available.
     */
    getTask(): Promise<ResearchTaskResponse>;
}

/**
 * HTTP status codes
 */
declare enum HttpStatusCode {
    BadRequest = 400,
    NotFound = 404,
    Unauthorized = 401,
    Forbidden = 403,
    TooManyRequests = 429,
    RequestTimeout = 408,
    InternalServerError = 500,
    ServiceUnavailable = 503
}
/**
 * Base error class for all Exa API errors
 */
declare class ExaError extends Error {
    /**
     * HTTP status code
     */
    statusCode: number;
    /**
     * ISO timestamp from API
     */
    timestamp?: string;
    /**
     * Path that caused the error (may be undefined for client-side errors)
     */
    path?: string;
    /**
     * Create a new ExaError
     * @param message Error message
     * @param statusCode HTTP status code
     * @param timestamp ISO timestamp from API
     * @param path Path that caused the error
     */
    constructor(message: string, statusCode: number, timestamp?: string, path?: string);
}

declare const isBeta = false;
/**
 * Search options for performing a search query.
 * @typedef {Object} SearchOptions
 * @property {number} [numResults] - Number of search results to return. Default 10. Max 10 for basic plans.
 * @property {string[]} [includeDomains] - List of domains to include in the search.
 * @property {string[]} [excludeDomains] - List of domains to exclude in the search.
 * @property {string} [startCrawlDate] - Start date for results based on crawl date.
 * @property {string} [endCrawlDate] - End date for results based on crawl date.
 * @property {string} [startPublishedDate] - Start date for results based on published date.
 * @property {string} [endPublishedDate] - End date for results based on published date.
 * @property {string} [category] - A data category to focus on, with higher comprehensivity and data cleanliness. Currently, the only category is company.
 * @property {string[]} [includeText] - List of strings that must be present in webpage text of results. Currently only supports 1 string of up to 5 words.
 * @property {string[]} [excludeText] - List of strings that must not be present in webpage text of results. Currently only supports 1 string of up to 5 words.
 * @property {string[]} [flags] - Experimental flags
 */
type BaseSearchOptions = {
    numResults?: number;
    includeDomains?: string[];
    excludeDomains?: string[];
    startCrawlDate?: string;
    endCrawlDate?: string;
    startPublishedDate?: string;
    endPublishedDate?: string;
    category?: "company" | "research paper" | "news" | "pdf" | "github" | "tweet" | "personal site" | "linkedin profile" | "financial report";
    includeText?: string[];
    excludeText?: string[];
    flags?: string[];
};
/**
 * Search options for performing a search query.
 * @typedef {Object} RegularSearchOptions
 */
type RegularSearchOptions = BaseSearchOptions & {
    /**
     * If true, the search results are moderated for safety.
     */
    moderation?: boolean;
    useAutoprompt?: boolean;
    type?: "keyword" | "neural" | "auto";
};
/**
 * Options for finding similar links.
 * @typedef {Object} FindSimilarOptions
 * @property {boolean} [excludeSourceDomain] - If true, excludes links from the base domain of the input.
 */
type FindSimilarOptions = BaseSearchOptions & {
    excludeSourceDomain?: boolean;
};
type ExtrasOptions = {
    links?: number;
    imageLinks?: number;
};
/**
 * Search options for performing a search query.
 * @typedef {Object} ContentsOptions
 * @property {TextContentsOptions | boolean} [text] - Options for retrieving text contents.
 * @property {HighlightsContentsOptions | boolean} [highlights] - Options for retrieving highlights.
 * @property {SummaryContentsOptions | boolean} [summary] - Options for retrieving summary.
 * @property {LivecrawlOptions} [livecrawl] - Options for livecrawling contents. Default is "never" for neural/auto search, "fallback" for keyword search.
 * @property {number} [livecrawlTimeout] - The timeout for livecrawling. Max and default is 10000ms.
 * @property {boolean} [filterEmptyResults] - If true, filters out results with no contents. Default is true.
 * @property {number} [subpages] - The number of subpages to return for each result, where each subpage is derived from an internal link for the result.
 * @property {string | string[]} [subpageTarget] - Text used to match/rank subpages in the returned subpage list. You could use "about" to get *about* page for websites. Note that this is a fuzzy matcher.
 * @property {ExtrasOptions} [extras] - Miscelleneous data derived from results
 */
type ContentsOptions = {
    text?: TextContentsOptions | true;
    highlights?: HighlightsContentsOptions | true;
    summary?: SummaryContentsOptions | true;
    livecrawl?: LivecrawlOptions;
    livecrawlTimeout?: number;
    filterEmptyResults?: boolean;
    subpages?: number;
    subpageTarget?: string | string[];
    extras?: ExtrasOptions;
} & (typeof isBeta extends true ? {} : {});
/**
 * Options for livecrawling contents
 * @typedef {string} LivecrawlOptions
 */
type LivecrawlOptions = "never" | "fallback" | "always" | "auto";
/**
 * Options for retrieving text from page.
 * @typedef {Object} TextContentsOptions
 * @property {number} [maxCharacters] - The maximum number of characters to return.
 * @property {boolean} [includeHtmlTags] - If true, includes HTML tags in the returned text. Default: false
 */
type TextContentsOptions = {
    maxCharacters?: number;
    includeHtmlTags?: boolean;
};
/**
 * Options for retrieving highlights from page.
 * @typedef {Object} HighlightsContentsOptions
 * @property {string} [query] - The query string to use for highlights search.
 * @property {number} [numSentences] - The number of sentences to return for each highlight.
 * @property {number} [highlightsPerUrl] - The number of highlights to return for each URL.
 */
type HighlightsContentsOptions = {
    query?: string;
    numSentences?: number;
    highlightsPerUrl?: number;
};
/**
 * Represents a JSON Schema definition used for structured summary output.
 * To learn more visit https://json-schema.org/overview/what-is-jsonschema.
 */
type JSONSchema = {
    $schema?: string;
    title?: string;
    description?: string;
    type: "object" | "array" | "string" | "number" | "boolean" | "null" | "integer";
    properties?: Record<string, JSONSchema>;
    items?: JSONSchema | JSONSchema[];
    required?: string[];
    enum?: any[];
    additionalProperties?: boolean | JSONSchema;
    definitions?: Record<string, JSONSchema>;
    patternProperties?: Record<string, JSONSchema>;
    allOf?: JSONSchema[];
    anyOf?: JSONSchema[];
    oneOf?: JSONSchema[];
    not?: JSONSchema;
};
/**
 * Options for retrieving summary from page.
 * @typedef {Object} SummaryContentsOptions
 * @property {string} [query] - The query string to use for summary generation.
 * @property {JSONSchema} [schema] - JSON schema for structured output from summary.
 */
type SummaryContentsOptions = {
    query?: string;
    schema?: JSONSchema;
};
/**
 * @typedef {Object} TextResponse
 * @property {string} text - Text from page
 */
type TextResponse = {
    text: string;
};
/**
 * @typedef {Object} HighlightsResponse
 * @property {string[]} highlights - The highlights as an array of strings.
 * @property {number[]} highlightScores - The corresponding scores as an array of floats, 0 to 1
 */
type HighlightsResponse = {
    highlights: string[];
    highlightScores: number[];
};
/**
 * @typedef {Object} SummaryResponse
 * @property {string} summary - The generated summary of the page content.
 */
type SummaryResponse = {
    summary: string;
};
/**
 * @typedef {Object} ExtrasResponse
 * @property {string[]} links - The links on the page of a result
 * @property {string[]} imageLinks - The image links on the page of a result
 */
type ExtrasResponse = {
    extras: {
        links?: string[];
        imageLinks?: string[];
    };
};
/**
 * @typedef {Object} SubpagesResponse
 * @property {ContentsResultComponent<T extends ContentsOptions>} subpages - The subpages for a result
 */
type SubpagesResponse<T extends ContentsOptions> = {
    subpages: ContentsResultComponent<T>[];
};
type Default<T extends {}, U> = [keyof T] extends [never] ? U : T;
/**
 * @typedef {Object} ContentsResultComponent
 * Depending on 'ContentsOptions', this yields a combination of 'TextResponse', 'HighlightsResponse', 'SummaryResponse', or an empty object.
 *
 * @template T - A type extending from 'ContentsOptions'.
 */
type ContentsResultComponent<T extends ContentsOptions> = Default<(T["text"] extends object | true ? TextResponse : {}) & (T["highlights"] extends object | true ? HighlightsResponse : {}) & (T["summary"] extends object | true ? SummaryResponse : {}) & (T["subpages"] extends number ? SubpagesResponse<T> : {}) & (T["extras"] extends object ? ExtrasResponse : {}), TextResponse>;
/**
 * Represents the cost breakdown related to contents retrieval. Fields are optional because
 * only non-zero costs are included.
 * @typedef {Object} CostDollarsContents
 * @property {number} [text] - The cost in dollars for retrieving text.
 * @property {number} [highlights] - The cost in dollars for retrieving highlights.
 * @property {number} [summary] - The cost in dollars for retrieving summary.
 */
type CostDollarsContents = {
    text?: number;
    highlights?: number;
    summary?: number;
};
/**
 * Represents the cost breakdown related to search. Fields are optional because
 * only non-zero costs are included.
 * @typedef {Object} CostDollarsSeearch
 * @property {number} [neural] - The cost in dollars for neural search.
 * @property {number} [keyword] - The cost in dollars for keyword search.
 */
type CostDollarsSeearch = {
    neural?: number;
    keyword?: number;
};
/**
 * Represents the total cost breakdown. Only non-zero costs are included.
 * @typedef {Object} CostDollars
 * @property {number} total - The total cost in dollars.
 * @property {CostDollarsSeearch} [search] - The cost breakdown for search.
 * @property {CostDollarsContents} [contents] - The cost breakdown for contents.
 */
type CostDollars = {
    total: number;
    search?: CostDollarsSeearch;
    contents?: CostDollarsContents;
};
/**
 * Represents a search result object.
 * @typedef {Object} SearchResult
 * @property {string} title - The title of the search result.
 * @property {string} url - The URL of the search result.
 * @property {string} [publishedDate] - The estimated creation date of the content.
 * @property {string} [author] - The author of the content, if available.
 * @property {number} [score] - Similarity score between the query/url and the result.
 * @property {string} id - The temporary ID for the document.
 * @property {string} [image] - A representative image for the content, if any.
 * @property {string} [favicon] - A favicon for the site, if any.
 */
type SearchResult<T extends ContentsOptions> = {
    title: string | null;
    url: string;
    publishedDate?: string;
    author?: string;
    score?: number;
    id: string;
    image?: string;
    favicon?: string;
} & ContentsResultComponent<T>;
/**
 * Represents a search response object.
 * @typedef {Object} SearchResponse
 * @property {Result[]} results - The list of search results.
 * @property {string} [autopromptString] - The autoprompt string, if applicable.
 * @property {string} [autoDate] - The autoprompt date, if applicable.
 * @property {string} requestId - The request ID for the search.
 * @property {CostDollars} [costDollars] - The cost breakdown for this request.
 */
type SearchResponse<T extends ContentsOptions> = {
    results: SearchResult<T>[];
    autopromptString?: string;
    autoDate?: string;
    requestId: string;
    costDollars?: CostDollars;
};
/**
 * Options for the answer endpoint
 * @typedef {Object} AnswerOptions
 * @property {boolean} [stream] - Whether to stream the response. Default false.
 * @property {boolean} [text] - Whether to include text in the source results. Default false.
 * @property {"exa" | "exa-pro"} [model] - The model to use for generating the answer. Default "exa".
 * @property {string} [systemPrompt] - A system prompt to guide the LLM's behavior when generating the answer.
 * @property {Object} [outputSchema] - A JSON Schema specification for the structure you expect the output to take
 */
type AnswerOptions = {
    stream?: boolean;
    text?: boolean;
    model?: "exa" | "exa-pro";
    systemPrompt?: string;
    outputSchema?: Record<string, unknown>;
};
/**
 * Represents an answer response object from the /answer endpoint.
 * @typedef {Object} AnswerResponse
 * @property {string | Object} answer - The generated answer text (or an object matching `outputSchema`, if provided)
 * @property {SearchResult<{}>[]} citations - The sources used to generate the answer.
 * @property {CostDollars} [costDollars] - The cost breakdown for this request.
 * @property {string} [requestId] - Optional request ID for the answer.
 */
type AnswerResponse = {
    answer: string | Record<string, unknown>;
    citations: SearchResult<{}>[];
    requestId?: string;
    costDollars?: CostDollars;
};
type AnswerStreamChunk = {
    /**
     * The partial text content of the answer (if present in this chunk).
     */
    content?: string;
    /**
     * Citations associated with the current chunk of text (if present).
     */
    citations?: Array<{
        id: string;
        url: string;
        title?: string;
        publishedDate?: string;
        author?: string;
        text?: string;
    }>;
};
/**
 * Represents a streaming answer response chunk from the /answer endpoint.
 * @typedef {Object} AnswerStreamResponse
 * @property {string} [answer] - A chunk of the generated answer text.
 * @property {SearchResult<{}>[]]} [citations] - The sources used to generate the answer.
 */
type AnswerStreamResponse = {
    answer?: string;
    citations?: SearchResult<{}>[];
};
/**
 * The Exa class encapsulates the API's endpoints.
 */
declare class Exa {
    private baseURL;
    private headers;
    /**
     * Websets API client
     */
    websets: WebsetsClient;
    /**
     * Research API client
     */
    research: ResearchClient;
    /**
     * Helper method to separate out the contents-specific options from the rest.
     */
    private extractContentsOptions;
    /**
     * Constructs the Exa API client.
     * @param {string} apiKey - The API key for authentication.
     * @param {string} [baseURL] - The base URL of the Exa API.
     */
    constructor(apiKey?: string, baseURL?: string);
    /**
     * Makes a request to the Exa API.
     * @param {string} endpoint - The API endpoint to call.
     * @param {string} method - The HTTP method to use.
     * @param {any} [body] - The request body for POST requests.
     * @param {Record<string, any>} [params] - The query parameters.
     * @returns {Promise<any>} The response from the API.
     * @throws {ExaError} When any API request fails with structured error information
     */
    request<T = unknown>(endpoint: string, method: string, body?: any, params?: Record<string, any>): Promise<T>;
    /**
     * Performs a search with an Exa prompt-engineered query.
     *
     * @param {string} query - The query string.
     * @param {RegularSearchOptions} [options] - Additional search options
     * @returns {Promise<SearchResponse<{}>>} A list of relevant search results.
     */
    search(query: string, options?: RegularSearchOptions): Promise<SearchResponse<{}>>;
    /**
     * Performs a search with an Exa prompt-engineered query and returns the contents of the documents.
     *
     * @param {string} query - The query string.
     * @param {RegularSearchOptions & T} [options] - Additional search + contents options
     * @returns {Promise<SearchResponse<T>>} A list of relevant search results with requested contents.
     */
    searchAndContents<T extends ContentsOptions>(query: string, options?: RegularSearchOptions & T): Promise<SearchResponse<T>>;
    /**
     * Finds similar links to the provided URL.
     * @param {string} url - The URL for which to find similar links.
     * @param {FindSimilarOptions} [options] - Additional options for finding similar links.
     * @returns {Promise<SearchResponse<{}>>} A list of similar search results.
     */
    findSimilar(url: string, options?: FindSimilarOptions): Promise<SearchResponse<{}>>;
    /**
     * Finds similar links to the provided URL and returns the contents of the documents.
     * @param {string} url - The URL for which to find similar links.
     * @param {FindSimilarOptions & T} [options] - Additional options for finding similar links + contents.
     * @returns {Promise<SearchResponse<T>>} A list of similar search results, including requested contents.
     */
    findSimilarAndContents<T extends ContentsOptions>(url: string, options?: FindSimilarOptions & T): Promise<SearchResponse<T>>;
    /**
     * Retrieves contents of documents based on URLs.
     * @param {string | string[] | SearchResult[]} urls - A URL or array of URLs, or an array of SearchResult objects.
     * @param {ContentsOptions} [options] - Additional options for retrieving document contents.
     * @returns {Promise<SearchResponse<T>>} A list of document contents for the requested URLs.
     */
    getContents<T extends ContentsOptions>(urls: string | string[] | SearchResult<T>[], options?: T): Promise<SearchResponse<T>>;
    /**
     * Generate an answer to a query.
     * @param {string} query - The question or query to answer.
     * @param {AnswerOptions} [options] - Additional options for answer generation.
     * @returns {Promise<AnswerResponse>} The generated answer and source references.
     *
     * Example with systemPrompt:
     * ```ts
     * const answer = await exa.answer("What is quantum computing?", {
     *   text: true,
     *   model: "exa-pro",
     *   systemPrompt: "Answer in a technical manner suitable for experts."
     * });
     * ```
     *
     * Note: For streaming responses, use the `streamAnswer` method:
     * ```ts
     * for await (const chunk of exa.streamAnswer(query)) {
     *   // Handle chunks
     * }
     * ```
     */
    answer(query: string, options?: AnswerOptions): Promise<AnswerResponse>;
    /**
     * Stream an answer as an async generator
     *
     * Each iteration yields a chunk with partial text (`content`) or new citations.
     * Use this if you'd like to read the answer incrementally, e.g. in a chat UI.
     *
     * Example usage:
     * ```ts
     * for await (const chunk of exa.streamAnswer("What is quantum computing?", {
     *   text: false,
     *   systemPrompt: "Answer in a concise manner suitable for beginners."
     * })) {
     *   if (chunk.content) process.stdout.write(chunk.content);
     *   if (chunk.citations) {
     *     console.log("\nCitations: ", chunk.citations);
     *   }
     * }
     * ```
     */
    streamAnswer(query: string, options?: {
        text?: boolean;
        model?: "exa" | "exa-pro";
        systemPrompt?: string;
        outputSchema?: Record<string, unknown>;
    }): AsyncGenerator<AnswerStreamChunk>;
    private processChunk;
    private parseSSEStream;
}

export { type AnswerOptions, type AnswerResponse, type AnswerStreamChunk, type AnswerStreamResponse, type BaseSearchOptions, type ContentsOptions, type ContentsResultComponent, type CostDollars, type CostDollarsContents, type CostDollarsSeearch, type CreateEnrichmentParameters, CreateEnrichmentParametersFormat, type CreateWebhookParameters, type CreateWebsetParameters, type CreateWebsetSearchParameters, CreateWebsetSearchParametersBehaviour, type Default, type EnrichmentResult, type Event, EventType, Exa, ExaError, type ExtrasOptions, type ExtrasResponse, type FindSimilarOptions, type GetWebsetResponse, type HighlightsContentsOptions, type HighlightsResponse, HttpStatusCode, type JSONSchema, type ListEventsResponse, type ListWebhooksOptions, type ListWebhooksResponse, type ListWebsetItemResponse, type ListWebsetsOptions, type ListWebsetsResponse, type LivecrawlOptions, type RegularSearchOptions, ResearchClient, ResearchStatus, type ResearchTaskResponse, type SearchResponse, type SearchResult, type SubpagesResponse, type SummaryContentsOptions, type SummaryResponse, type TextContentsOptions, type TextResponse, type UpdateWebhookParameters, type UpdateWebsetRequest, type Webhook, WebhookStatus, type Webset, type WebsetEnrichment, WebsetEnrichmentFormat, WebsetEnrichmentStatus, WebsetEnrichmentsClient, type WebsetItem, WebsetItemEvaluationSatisfied, WebsetItemSource, WebsetItemsClient, type WebsetSearch, WebsetSearchCanceledReason, WebsetSearchStatus, WebsetSearchesClient, WebsetStatus, WebsetWebhooksClient, WebsetsClient, Exa as default };
